# fantastic-octo-happiness

> Disclamer: The name was generated by github, I didn't know what name to use.

## Explanation

This application is part of an interview. The objective is to use the **Spotify API** to make an simple application to showcase my React + Redux skills.

## Technologies

This section aims to explain the decition behind some of the thrid party libraries I use in the project.

### React

React is used because is part of the interview requirements, but its also the library I use in my personal projects.

I love React, its an amazing tool, with an awesome ecosystem surrounding it. Over the years I've used many libraries and framework for developing apps: jQuery, Angular, Google Closure, Handlebars, etc. They all have many advantages, but I have always have had the same issue, but usually they struggle with one thing: **state management**. The are two main problems: *having consistent state across the application* and *keeping the state synced with the view*. In jQuery state can be easier to manage (depends on how you structure it), but its hard to synced with the view. In Angular the reverse is true, the framework manages the syncing, but the state can change with angular events, user events and even simple objects mutations.

React on the other side, manages to do the two things beatifully. The state is immutable and can only be changes via a simple but powerfull API, [`Component#setState(updated, [callback])`](https://facebook.github.io/react/docs/react-component.html#setstate), it ensures your state can only be changed inside each component, in an explicit manner, neither the *parent* nor the *children* can modify that state. On the other side, syncing the state with the view is done by **rendering** and **re-rendering** every time the state (or the props) changes. This allow for predictable apps, so predictable that even the testing tools can take advantage of that, for example [jest snapshots](https://facebook.github.io/jest/docs/snapshot-testing.html).

### Redux

There are many reason to use Redux (or any Flux like state management) and many people have written great posts about it, so I will try to be brief. Having a single source of truth about the state of your application allows for predictable and testeable code.

One extra point for Redux are middlewares, that allow to integrate many tools, like side effect handlers, based on the **actions**

### Flowtype

I love static typing and more so if they can be infered by the analyzer, and flow gives you exactly that.

One thing I thinks its essential is documentation, but writing tends to be tedious and hard to mantain. A simple solution is using the code as documentation, types allow you to do that. Having expresive names and types can give 80% of the information you need about an function.

Also, **flow** is designed to find errors (**TypeScript** is design arround tooling: autocomplete, etc.). Many times I have caugth an error before running the code, because **flow** highlighted that the parameter type was wrong. Finally, **refactors**, refactors are so much easier if something tells you that you haven't changed that function call for the new parameters.

### Styled Components

This is more of a personal choice. There are many great tools for styling in React, but I love functional programming, and this library gives you the ability to easily generate functions that apply styles to your **Components**, and since they are all pure functions, you can compose them. Example:

```
const MegaStyledComponent = applyFlexContainer(
  applyFullHeight(
    applyScrollable(
      applyBordered(
        SimpleComponent
      )
    )
  )
)
```

This is not a good example (please don't do this), but it showcases what you can do.

### React Router V4

There are many routers for react. I choose this because it's just components, nothing else. They are components that "react" to the changes in the URL. In this case I'm using [ConnectedRouter](https://github.com/ReactTraining/react-router/tree/master/packages/react-router-redux) that its not connected to the URL but to the redux state and there is a middleware that syncs the state with the URL.

It has a simple, really declarative API, and it makes the routes the "react way", with composable components.

### Redux Observables

Even though this app is small and a side effects library is not really necessary, using one can really help keep your app testeable and scalable.

Observables have a complex API and add some boilerplate to the application but once you understand how they work, its really easy to know whats happening and its simple to debug.
